package main

import (
	"fmt"
	"strings"
)

/*
	Проблемы в коде из примера начинаются с первой строчки, в которой объявляется глобальная переменная.
	Такое решение как минимум создает сложности в отладке и добавляют риск потенциальной гонки при многопоточном обращении к переменной.

	Потенциальными решениями данной проблемы являются: возврат строки из функции someFunc() и последующее присваивание, либо передача этой строки как указателя,
	в своем решении я выбрал второй вариант.

	Следующей проблемой представленного кода является создание слайса строки, что по своей логике не копирует данные,
	а копирует указатель на ту же область памяти.
	При выходе из функции someFunc(), мы получаем утечку памяти, потому что наша глобальная переменная все еще указывает на массив (длиной 2¹⁰ = 1024 символа)
	и сборщик мусора из-за этого не освобождает память.

	Решением данной проблемы является явное копирование данных, для этой задачи существует функция Clone из пакета strings, которой я и воспользовался.
*/

func someFunc(justString *string) { // принимаем указатель на строку аргументом
	v := createHugeString(1 << 10)
	*justString = strings.Clone(v[:100]) // полностью копируем (клонируем) значение из среза и присваиваем его нашей строке
}

// функция для создания большой строки
func createHugeString(length int) string {
	return strings.Repeat("W", length) // повторяем символ "W" length раз
}

func main() {
	var justString string // объявляем строку
	someFunc(&justString) // передаем указатель на строку
	fmt.Println(justString)
}
