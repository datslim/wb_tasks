package main

import (
	"fmt"
	"log"
)

const (
	BIT = int64(1) // 1 в двоичной системе
)

// функция для установки или очистки бита в числе
// аргументы:
// number - указатель на число, в котором нужно установить бит
// position - позиция бита (начиная с 1)
// bit - значение бита (0 или 1)
func setBit(number *int64, position, bit int) {
	if position < 1 || position > 64 { // проверяем валидность входящих данных для позиции
		log.Printf("Ошибка: позиция бита (%d) вне диапазона (от 1 до 64)", position)
		return
	}

	if bit != 0 && bit != 1 { // проверяем валидность входящих данных для устанавливаемого бита
		log.Printf("Ошибка: бит не может быть %d (должен быть 0 или 1)", bit)
		return
	}

	position-- // уменьшаем позицию на единицу, поскольку принимаем позицию бита (начиная с 1)
	switch bit {
	case 0:
		// очищаем бит с помощью  инвертированной маски и логического AND
		mask := ^(BIT << position)
		*number = *number & mask
	case 1:
		// устанавливаем бит с помощью маски и логического OR
		mask := BIT << position
		*number = *number | mask
	}
}
func main() {
	var value int64 = 5 // 101 в двоичной системе
	fmt.Printf("Бинарное представление числа %d до установки первого бита в 0: %b\n", value, value)
	setBit(&value, 1, 0) // 100 в двоичной системе
	fmt.Printf("Бинарное представление числа 5 после установки первого бита в 0: %b (%d)\n", value, value)
	setBit(&value, 2, 1) // 110 в двоичной системе
	fmt.Printf("Бинарное представление числа 4 после установки второго бита в 1: %b (%d)\n", value, value)

	// задаем неправильные параметры
	setBit(&value, 65, 3) // 65 позиция (максимум 64)
	setBit(&value, 1, 3)  // пытаемся установить в бит 3 (в двоичной системе исчисления такое невозможно)
}
